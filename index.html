<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Availability</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: var(--tg-theme-bg-color, #fff);
            --text-color: var(--tg-theme-text-color, #000);
            --secondary-bg: var(--tg-theme-secondary-bg-color, #f0f0f0);
            --button-color: var(--tg-theme-button-color, #2481cc);
            --green: #4caf50;
            --heatmap-base: 76, 175, 80; /* RGB for green */
        }
        body {
            font-family: -apple-system, system-ui, sans-serif;
            margin: 0; padding: 0; 
            background-color: var(--bg-color); color: var(--text-color);
            user-select: none;
        }
        .container { display: flex; flex-direction: column; height: 100vh; }
        header { padding: 15px; text-align: center; border-bottom: 1px solid var(--secondary-bg); }
        
        /* --- TIME GRID STYLES --- */
        .time-grid-wrapper { flex-grow: 1; overflow: auto; display: none; } /* Hidden by default */
        .grid-container {
            display: grid;
            grid-template-columns: 50px repeat(5, 1fr); 
            gap: 1px; background-color: var(--secondary-bg); border-top: 1px solid var(--secondary-bg);
        }
        .header-cell {
            background-color: var(--bg-color); font-weight: bold; font-size: 13px; text-align: center;
            padding: 10px 2px; position: sticky; top: 0; z-index: 20;
        }
        .time-col {
            background-color: var(--bg-color); font-size: 11px; text-align: right;
            padding-right: 8px; position: sticky; left: 0; z-index: 10;
        }
        .slot { height: 35px; background-color: var(--bg-color); position: relative; }

        /* --- CALENDAR STYLES --- */
        .calendar-wrapper { flex-grow: 1; overflow: auto; padding: 20px; display: none; }
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
        }
        .cal-day {
            aspect-ratio: 1;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background-color: var(--secondary-bg);
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .cal-day-name { font-size: 10px; opacity: 0.7; margin-bottom: 2px; }
        
        /* --- SHARED INTERACTIVE --- */
        /* Heatmap uses background-color. Selection uses border/shadow. */
        .selected {
            box-shadow: inset 0 0 0 3px var(--button-color); /* Inner border to show selection */
        }
        
        /* Icon to clearly indicate selection */
        .selected::after {
            content: 'âœ“';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            color: var(--button-color);
            font-weight: bold;
        }

        #loader {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(0,0,0,0.5); display: none; 
            align-items: center; justify-content: center; color: white;
            z-index: 100;
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h2 id="event-title">Loading...</h2>
        <p class="hint" id="hint-text">Select your availability</p>
    </header>

    <!-- MODE 1: TIME GRID -->
    <div id="time-view" class="time-grid-wrapper">
        <div id="grid" class="grid-container"></div>
    </div>

    <!-- MODE 2: CALENDAR GRID -->
    <div id="date-view" class="calendar-wrapper">
        <div id="calendar" class="calendar-grid"></div>
    </div>
</div>

<div id="loader">Processing...</div>

<script>
    const tg = window.Telegram.WebApp;
    tg.expand(); 

    const BACKEND_API_URL = "";

    // Get Params
    const urlParams = new URLSearchParams(window.location.search);
    const eventId = urlParams.get('eventId');
    
    // Fallback if URL params fail, though normally we expect data from API
    let eventName = urlParams.get('eventName') || "Event";
    let mode = urlParams.get('mode') || 'time';

    const userId = tg.initDataUnsafe.user?.id?.toString() || 'anon';

    // State
    const selectedSlots = new Set();
    let isDragging = false;
    let paintMode = true; // true = adding, false = removing

    // --- MAIN FLOW ---

    async function loadData() {
        if (!eventId) return null;
        try {
            const res = await fetch(`${BACKEND_API_URL}/get_event_data?eventId=${eventId}`);
            return await res.json();
        } catch (e) {
            console.error(e);
            return null;
        }
    }

    loadData().then(data => {
        if (data && !data.error) {
            eventName = data.name;
            mode = data.mode;
            document.getElementById('event-title').innerText = eventName;

            // Process Votes
            const votes = data.votes || {};
            const slotCounts = {};
            let totalVoters = 0;
            const voters = new Set();

            Object.keys(votes).forEach(uid => {
                voters.add(uid);
                votes[uid].forEach(slot => {
                    slotCounts[slot] = (slotCounts[slot] || 0) + 1;
                });

                // If it's me, pre-fill selection
                if (uid === userId) {
                    votes[uid].forEach(s => selectedSlots.add(s));
                }
            });
            totalVoters = voters.size;

            if (mode === 'date') {
                initCalendar(data.start_date, data.end_date, slotCounts, totalVoters);
            } else {
                initTimeGrid(slotCounts, totalVoters);
            }
        } else {
            // Fallback for new event or error
            document.getElementById('event-title').innerText = eventName;
            if (mode === 'date') initCalendar(null, null, {}, 0);
            else initTimeGrid({}, 0);
        }
    });

    // --- RENDERERS ---

    function initCalendar(startDateStr, endDateStr, slotCounts, totalVoters) {
        document.getElementById('date-view').style.display = 'block';
        document.getElementById('hint-text').innerText = "Drag across dates you are available";
        
        const cal = document.getElementById('calendar');
        const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

        // Determine range
        let start = startDateStr ? new Date(startDateStr) : new Date();
        let end;

        if (endDateStr) {
            end = new Date(endDateStr);
        } else {
            end = new Date(start);
            end.setDate(start.getDate() + 34); // Default 35 days
        }

        // Loop dates
        let current = new Date(start);
        while (current <= end) {
            const dateStr = current.toISOString().split('T')[0];
            const dayName = days[current.getDay()];
            const dayNum = current.getDate();

            const cell = document.createElement('div');
            cell.className = 'cal-day';
            cell.dataset.id = dateStr;
            cell.innerHTML = `<span class="cal-day-name">${dayName}</span><span>${dayNum}</span>`;
            
            // Heatmap
            applyHeatmap(cell, dateStr, slotCounts, totalVoters);

            // Selection State
            if (selectedSlots.has(dateStr)) cell.classList.add('selected');

            // Drag Events
            attachDragEvents(cell);

            cal.appendChild(cell);

            // Next day
            current.setDate(current.getDate() + 1);
        }
    }

    function initTimeGrid(slotCounts, totalVoters) {
        document.getElementById('time-view').style.display = 'block';
        document.getElementById('hint-text').innerText = "Drag to paint times";

        const grid = document.getElementById('grid');
        const dayLabels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
        
        // Header
        const corner = document.createElement('div');
        corner.className = 'header-cell';
        grid.appendChild(corner);
        dayLabels.forEach(d => {
            const h = document.createElement('div');
            h.className = 'header-cell';
            h.innerText = d;
            grid.appendChild(h);
        });

        // Rows
        for (let h = 8; h < 22; h++) {
            const timeCol = document.createElement('div');
            timeCol.className = 'time-col';
            timeCol.innerText = `${h}:00`;
            grid.appendChild(timeCol);

            for (let d = 0; d < dayLabels.length; d++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                const id = `${d}-${h}`;
                slot.dataset.id = id;
                
                // Heatmap
                applyHeatmap(slot, id, slotCounts, totalVoters);

                // Selection State
                if (selectedSlots.has(id)) slot.classList.add('selected');

                // Drag Events
                attachDragEvents(slot);
                
                grid.appendChild(slot);
            }
        }
    }

    function applyHeatmap(el, id, slotCounts, totalVoters) {
        if (!totalVoters) return;
        const count = slotCounts[id] || 0;
        if (count > 0) {
            const saturation = count / totalVoters;
            // Green with opacity. Min 0.1 opacity so it's visible.
            el.style.backgroundColor = `rgba(76, 175, 80, ${saturation})`;
        }
    }

    // --- DRAG LOGIC (Shared) ---
    function attachDragEvents(el) {
        el.addEventListener('mousedown', startDrag);
        el.addEventListener('mouseenter', doDrag);
        el.addEventListener('touchstart', startTouch, {passive: false});
        el.addEventListener('touchmove', moveTouch, {passive: false});
    }

    document.addEventListener('mouseup', () => isDragging = false);
    document.addEventListener('touchend', () => isDragging = false);

    function startDrag(e) {
        // Prevent text selection
        e.preventDefault();
        isDragging = true;
        // Determine paint mode based on the *first* cell clicked
        // If it's already selected, we are erasing. Else painting.
        // We use 'currentTarget' because 'target' might be a child span
        const cell = e.currentTarget;
        paintMode = !cell.classList.contains('selected');
        toggleSlot(cell);
    }

    function doDrag(e) {
        if (isDragging) toggleSlot(e.currentTarget);
    }
    
    function startTouch(e) {
        if(e.cancelable) e.preventDefault();
        isDragging = true;
        const el = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
        const cell = el?.closest('.cal-day, .slot');
        if (cell) {
            paintMode = !cell.classList.contains('selected');
            toggleSlot(cell);
        }
    }

    function moveTouch(e) {
        if(e.cancelable) e.preventDefault();
        if (!isDragging) return;
        const el = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
        const cell = el?.closest('.cal-day, .slot');
        if (cell) toggleSlot(cell);
    }

    function toggleSlot(el) {
        if (!el) return;
        const id = el.dataset.id;
        if (paintMode) {
            if (!selectedSlots.has(id)) {
                el.classList.add('selected');
                selectedSlots.add(id);
            }
        } else {
            if (selectedSlots.has(id)) {
                el.classList.remove('selected');
                selectedSlots.delete(id);
            }
        }
    }

    // --- SUBMIT ---
    tg.MainButton.setText("SUBMIT");
    tg.MainButton.show();

    tg.MainButton.onClick(async () => {
        if (selectedSlots.size === 0) {
            tg.showAlert("Please select at least one option!");
            return;
        }

        const payload = {
            eventId: eventId,
            userId: userId,
            slots: Array.from(selectedSlots)
        };

        document.getElementById('loader').style.display = 'flex';
        
        try {
            await fetch(`${BACKEND_API_URL}/submit_availability`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            });
            tg.close();
        } catch (e) {
            document.getElementById('loader').style.display = 'none';
            tg.showAlert("Error saving. Check connection.");
        }
    });
</script>
</body>
</html>
